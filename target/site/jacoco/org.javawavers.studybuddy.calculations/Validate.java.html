<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="el"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">studybuddy</a> &gt; <a href="index.source.html" class="el_package">org.javawavers.studybuddy.calculations</a> &gt; <span class="el_source">Validate.java</span></div><h1>Validate.java</h1><pre class="source lang-java linenums">package org.javawavers.studybuddy.calculations;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

/**
 * The Validate class is responsible for validating the schedule of tasks by performing multiple
 * checks: - Ensuring that tasks are scheduled before their associated deadlines. - Ensuring that
 * tasks are scheduled within the available hours for each day. - Ensuring that all assignment tasks
 * (TaskType == 3) are scheduled, forcefully if needed. The methods in this class perform these
 * checks in sequence to guarantee that the schedule is both valid and feasible based on the
 * available time slots and deadlines for each task.
 */
<span class="nc" id="L15">public class Validate {</span>
  /**
   * Main method to validate the schedule using multiple validity checks. validSchedule - the 2D
   * array representing the schedule taskList - the list of tasks return - the validated schedule
   */
  public static int[][] validateSchedule(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L21">    int[][] deadValidSchedule = deadlineValidity(validSchedule, taskList);</span>
<span class="nc" id="L22">    int[][] avValidSchedule = availabilityValidity(deadValidSchedule, taskList);</span>
<span class="nc" id="L23">    return assignmentsValidity(avValidSchedule, taskList);</span>
  }

  /** Ensures that no task is scheduled after its associated deadline. */
  private static int[][] deadlineValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L28">    List&lt;Dates&gt; examList = new ArrayList&lt;&gt;(SimulateAnnealing.getExams());</span>
<span class="nc" id="L29">    LocalDate examDate = LocalDate.now();</span>

<span class="nc bnc" id="L31" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L33" title="All 2 branches missed.">        if (validSchedule[row][col] != 0) {</span>
<span class="nc" id="L34">          String subjectName = taskList.get(validSchedule[row][col]).getSubject();</span>

          // Find the corresponding exam date
<span class="nc bnc" id="L37" title="All 2 branches missed.">          for (Dates e : examList) {</span>
<span class="nc bnc" id="L38" title="All 2 branches missed.">            if (subjectName.equals(e.getSubName())) {</span>
<span class="nc" id="L39">              examDate = e.getDate();</span>
<span class="nc" id="L40">              break;</span>
            }
<span class="nc" id="L42">          }</span>

          // Check if the task is scheduled after the exam date
<span class="nc bnc" id="L45" title="All 2 branches missed.">          if (!examDate.isAfter(LocalDate.now().plusDays(col))) {</span>
<span class="nc" id="L46">            validSchedule[row][col] = 0; // Clear invalid task</span>
          }
        }
      }
    }
<span class="nc" id="L51">    return validSchedule;</span>
  }

  /** Ensures that tasks are scheduled within available hours for each day. */
  private static int[][] availabilityValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc bnc" id="L56" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc" id="L57">      double dayAvailability = Availability.getTotalAvailableHours(col);</span>

<span class="nc bnc" id="L59" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">        if (Availability.checkAvailability(col)) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">          if (validSchedule[row][col] != 0) {</span>
            // Deduct hours based on task type
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (dayAvailability &gt;= 2.0) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">              if (taskList.get(validSchedule[row][col]).getTaskType() == 1) {</span>
<span class="nc" id="L65">                dayAvailability -= 2.0;</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">              } else if (taskList.get(validSchedule[row][col]).getTaskType() == 2) {</span>
<span class="nc" id="L67">                dayAvailability -= 1.0 / 3.0;</span>
              } else {
<span class="nc" id="L69">                dayAvailability -= 2.0; // Default case</span>
              }
            } else {
<span class="nc" id="L72">              validSchedule[row][col] = 0; // Clear task if insufficient hours</span>
            }
          }
        } else {
<span class="nc" id="L76">          validSchedule[row][col] = 0; // Clear task if day is unavailable</span>
        }
      }
    }
<span class="nc" id="L80">    return validSchedule;</span>
  }

  /**
   * Ensures that all assignments (TaskType == 3) are scheduled, forcefully assigning them if
   * needed.
   */
  private static int[][] assignmentsValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L88">    List&lt;Dates&gt; deadLines = new ArrayList&lt;&gt;(SimulateAnnealing.getAssignments());</span>
    // Create a list of all unassigned tasks of type 3
<span class="nc" id="L90">    List&lt;Integer&gt; unassignedTasks = getIntegers(validSchedule, taskList);</span>

<span class="nc" id="L92">    int col = 0;</span>
    // Forcefully assign remaining tasks of type 3 to available slots
<span class="nc bnc" id="L94" title="All 2 branches missed.">    for (int taskIndex : unassignedTasks) {</span>
<span class="nc" id="L95">      boolean assigned = false;</span>
<span class="nc" id="L96">      Task currentTask = taskList.get(taskIndex); // Get the current task</span>

<span class="nc bnc" id="L98" title="All 2 branches missed.">      while (!assigned) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (col &lt; validSchedule[0].length) {</span>
          // Check if the day is available and before the task's deadline
<span class="nc bnc" id="L101" title="All 4 branches missed.">          if (Availability.checkAvailability(col) &amp;&amp; Dates.checkDate(currentTask, col, deadLines)) {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">              if (validSchedule[row][col] == 0) { // Empty slot found</span>
<span class="nc" id="L104">                validSchedule[row][col] = taskIndex; // Assign task</span>
<span class="nc" id="L105">                col++;</span>
<span class="nc" id="L106">                assigned = true;</span>
<span class="nc" id="L107">                break; // Exit inner loop</span>
              }
            }
          } else {
            // Continue to the next available day
<span class="nc" id="L112">            col++;</span>
          }
        }

<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (col == validSchedule[0].length) {</span>
          // Restart the procedure if no valid slot is found
<span class="nc" id="L118">          col = 0;</span>
        }
      }
<span class="nc" id="L121">    }</span>
<span class="nc" id="L122">    return validSchedule;</span>
  }

  private static List&lt;Integer&gt; getIntegers(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L126">    List&lt;Integer&gt; unassignedTasks = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">    for (int i = 0; i &lt; taskList.size(); i++) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">      if (taskList.get(i).getTaskType() == 3) {</span>
<span class="nc" id="L129">        unassignedTasks.add(i);</span>
      }
    }

    // Check if tasks are already scheduled, and remove them from unassignedTasks
<span class="nc bnc" id="L134" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc" id="L136">        int taskIndex = validSchedule[row][col];</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (unassignedTasks.contains(taskIndex)) {</span>
<span class="nc" id="L138">          unassignedTasks.remove(Integer.valueOf(taskIndex)); // Task already scheduled</span>
        }
      }
    }
<span class="nc" id="L142">    return unassignedTasks;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>
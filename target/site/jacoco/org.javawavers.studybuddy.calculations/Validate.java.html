<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Validate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">studybuddy</a> &gt; <a href="index.source.html" class="el_package">org.javawavers.studybuddy.calculations</a> &gt; <span class="el_source">Validate.java</span></div><h1>Validate.java</h1><pre class="source lang-java linenums">package org.javawavers.studybuddy.calculations;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

<span class="nc" id="L7">public class Validate {</span>
  /**
   * Main method to validate the schedule using multiple validity checks. validSchedule - the 2D
   * array representing the schedule taskList - the list of tasks return - the validated schedule
   */
  public static int[][] validateSchedule(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L13">    int[][] dValidSchedule = deadlineValidity(validSchedule, taskList);</span>
<span class="nc" id="L14">    int[][] avValidSchedule = availabilityValidity(dValidSchedule, taskList);</span>
<span class="nc" id="L15">    return assignmentsValidity(avValidSchedule, taskList);</span>
  }

  /** Ensures that no task is scheduled after its associated deadline. */
  private static int[][] deadlineValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L20">    List&lt;Dates&gt; examList = new ArrayList&lt;&gt;(SimulateAnnealing.getExams());</span>
<span class="nc" id="L21">    LocalDate examDate = LocalDate.now();</span>

<span class="nc bnc" id="L23" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc bnc" id="L24" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L25" title="All 2 branches missed.">        if (validSchedule[row][col] != 0) {</span>
<span class="nc" id="L26">          String subjectName = taskList.get(validSchedule[row][col]).getSubject();</span>

          // Find the corresponding exam date
<span class="nc bnc" id="L29" title="All 2 branches missed.">          for (Dates e : examList) {</span>
<span class="nc bnc" id="L30" title="All 2 branches missed.">            if (subjectName.equals(e.getSubName())) {</span>
<span class="nc" id="L31">              examDate = e.getDate();</span>
<span class="nc" id="L32">              break;</span>
            }
<span class="nc" id="L34">          }</span>

          // Check if the task is scheduled after the exam date
<span class="nc bnc" id="L37" title="All 2 branches missed.">          if (!examDate.isAfter(LocalDate.now().plusDays(col))) {</span>
<span class="nc" id="L38">            validSchedule[row][col] = 0; // Clear invalid task</span>
          }
        }
      }
    }
<span class="nc" id="L43">    return validSchedule;</span>
  }

  /** Ensures that tasks are scheduled within available hours for each day. */
  private static int[][] availabilityValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc bnc" id="L48" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc" id="L49">      double dayAvailability = Availability.getTotalAvailableHours(col);</span>

<span class="nc bnc" id="L51" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        if (Availability.checkAvailability(col)) {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">          if (validSchedule[row][col] != 0) {</span>
            // Deduct hours based on task type
<span class="nc bnc" id="L55" title="All 2 branches missed.">            if (dayAvailability &gt;= 2.0) {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">              if (taskList.get(validSchedule[row][col]).getTaskType() == 1) {</span>
<span class="nc" id="L57">                dayAvailability -= 2.0;</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">              } else if (taskList.get(validSchedule[row][col]).getTaskType() == 2) {</span>
<span class="nc" id="L59">                dayAvailability -= 1.0 / 3.0;</span>
              } else {
<span class="nc" id="L61">                dayAvailability -= 2.0; // Default case</span>
              }
            } else {
<span class="nc" id="L64">              validSchedule[row][col] = 0; // Clear task if insufficient hours</span>
            }
          }
        } else {
<span class="nc" id="L68">          validSchedule[row][col] = 0; // Clear task if day is unavailable</span>
        }
      }
    }
<span class="nc" id="L72">    return validSchedule;</span>
  }

  /**
   * Ensures that all assignments (TaskType == 3) are scheduled, forcefully assigning them if
   * needed.
   */
  private static int[][] assignmentsValidity(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L80">    List&lt;Dates&gt; deadLines = new ArrayList&lt;&gt;(SimulateAnnealing.getAssignments());</span>
    // Create a list of all unassigned tasks of type 3
<span class="nc" id="L82">    List&lt;Integer&gt; unassignedTasks = getIntegers(validSchedule, taskList);</span>

<span class="nc" id="L84">    int col = 0;</span>
    // Forcefully assign remaining tasks of type 3 to available slots
<span class="nc bnc" id="L86" title="All 2 branches missed.">    for (int taskIndex : unassignedTasks) {</span>
<span class="nc" id="L87">      boolean assigned = false;</span>
<span class="nc" id="L88">      Task currentTask = taskList.get(taskIndex); // Get the current task</span>

<span class="nc bnc" id="L90" title="All 2 branches missed.">      while (!assigned) {</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (col &lt; validSchedule[0].length) {</span>
          // Check if the day is available and before the task's deadline
<span class="nc bnc" id="L93" title="All 4 branches missed.">          if (Availability.checkAvailability(col) &amp;&amp; Dates.checkDate(currentTask, col, deadLines)) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">              if (validSchedule[row][col] == 0) { // Empty slot found</span>
<span class="nc" id="L96">                validSchedule[row][col] = taskIndex; // Assign task</span>
<span class="nc" id="L97">                col++;</span>
<span class="nc" id="L98">                assigned = true;</span>
<span class="nc" id="L99">                break; // Exit inner loop</span>
              }
            }
          } else {
            // Continue to the next available day
<span class="nc" id="L104">            col++;</span>
          }
        }

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (col == validSchedule[0].length) {</span>
          // Restart the procedure if no valid slot is found
<span class="nc" id="L110">          col = 0;</span>
        }
      }
<span class="nc" id="L113">    }</span>
<span class="nc" id="L114">    return validSchedule;</span>
  }

  private static List&lt;Integer&gt; getIntegers(int[][] validSchedule, List&lt;Task&gt; taskList) {
<span class="nc" id="L118">    List&lt;Integer&gt; unassignedTasks = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">    for (int i = 0; i &lt; taskList.size(); i++) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">      if (taskList.get(i).getTaskType() == 3) {</span>
<span class="nc" id="L121">        unassignedTasks.add(i);</span>
      }
    }

    // Check if tasks are already scheduled, and remove them from unassignedTasks
<span class="nc bnc" id="L126" title="All 2 branches missed.">    for (int col = 0; col &lt; validSchedule[0].length; col++) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      for (int row = 0; row &lt; 12; row++) {</span>
<span class="nc" id="L128">        int taskIndex = validSchedule[row][col];</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (unassignedTasks.contains(taskIndex)) {</span>
<span class="nc" id="L130">          unassignedTasks.remove(Integer.valueOf(taskIndex)); // Task already scheduled</span>
        }
      }
    }
<span class="nc" id="L134">    return unassignedTasks;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>